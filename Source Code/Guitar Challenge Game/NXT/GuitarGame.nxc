// GuitarGame -- Guitar Game Player
// NXT Guitar Challenge Game
// (c)Copyright 2009 by Dave Parker.  All Rights Reserved.
// www.nxtprograms.com

// Include data and code shared by both recording and playing
#include "GuitarShared.nxc"

// Constants
#define DY_SCORE_METER     50   // Height of the score meter
#define TICKS_LATE_SLOP    8    // Ticks late that a note can be to score
#define TICKS_EARLY_SLOP   8    // Ticks early that a note can be to score
#define TICKS_RELEASE_SLOP 12   // Ticks extra that a note can be held

// The file name of the song data file
string strFileNameSong;

// Data for the song playing state
int rgTickFret[6];     // the last time that each fret was played
int iNoteExtraLast;    // index of last extra note counted
int cNotesSongScored;  // number of song notes scored so far
int cNotesScore;       // number of song notes scored plus extra notes
int cNotesMissed;      // count of notes missed plus extra notes
int percentHit;        // percent of notes hit
int percentMeter;      // percent to display in the score meter
bool fNoteHeld;        // true if a note is still held since last check


// Let the user choose a song file, starting the search at indexStart.
// Display the song info on the screen and wait for the user to
// select one, move to the next or prev song, or abort.
// Read the selected song into memory and return the selected index.
int IndexChooseAndReadSongFile(int indexStart)
{
    // Let the user move through the indexes until one is chosen
    int index = indexStart;   // file index ("Song xx")
    int iDirection = 1;       // +1 for next, -1 for prev, 0 when chosen
    bool fFileFound = FALSE;  // Did we find at least one file?
    for (;;)
    {
         // Try to find a file with this index and read the header
         strFileNameSong = StrMakeSongFileName(index);
         if (FReadSongFile(strFileNameSong, FALSE))
         {
            // Display song info
            ClearScreen();
            CenterNumLine(LCD_LINE1, STR_FILENAME_BASE, index, STR_EMPTY);
            TextOut(0, LCD_LINE3, ByteArrayToStr(szSongTitle));
            TextOut(0, LCD_LINE4, ByteArrayToStr(szSongArtist));
            TextOut(0, LCD_LINE5, ByteArrayToStr(szSongAlbum));

            // Prompt for Prev/OK/Next
            iDirection = IDoPrevOKNextAlert();
            if (iDirection == 0)
               return index;    // user selected this file
            fFileFound = TRUE;
            indexStart = index;   // start search from this file
         }
            
         // Try next index, wrapping around at the min and max
         index = ((index - 1 + iDirection + MAX_FILES) % MAX_FILES) + 1;
         
         // Did we wrap back to the start and find no files?
         if (index == indexStart && !fFileFound)
            FatalError("No song files");  // didn't find any files
    }
}

// Display additional detail info on the loaded song, and prompt the user
// to play it or delete it.  If the user wants to play it, then read the
// complete song file and return true if the load was successful.
bool FPlayShowSongDetails(int indexSong)
{
    // Display song details
    ClearScreen();
    CenterNumLine(LCD_LINE1, STR_FILENAME_BASE, indexSong, STR_EMPTY);
    CenterTextOut(LCD_LINE2, ByteArrayToStr(szSongTitle));
    CenterNumLine(LCD_LINE4, "High Score = ", bSongHighScore, STR_EMPTY);
    if (bSecStartDelay > 0 && bSecStartDelay < 60)
    {
       if (bSecStartDelay > 10)
          CenterNumLine(LCD_LINE6, "Start at 0:", bSecStartDelay, STR_EMPTY);
       else
          CenterNumLine(LCD_LINE6, "Start at 0:0", bSecStartDelay, STR_EMPTY);
    }
    
    // Prompt to go Back, Play, or Delete
    switch (IDo3ButtonAlert("Back", "Play", "Del"))
    {
    case -1:
       // Back (cancel)
       return false;
    case 0:
       // Play: Read the complete file
       NormalBeep();
       return FReadSongFile(strFileNameSong, TRUE);
    case 1:
       // Delete: Prompt to confirm, then delete the file
       ClearScreen();
       CenterNumLine(LCD_LINE3, "Delete Song ", indexSong, "?");
       CenterTextOut(LCD_LINE5, ByteArrayToStr(szSongTitle));
       if (FEnterTwoButtonAlert("Yes", "No"))
          DeleteFile(strFileNameSong);
       return false;
    }
}

// Draw the score meter with the score in percentMeter
void DrawScoreMeter()
{
   // Draw the frame for the meter as a rectangle with 4 lines
    dlArgs.StartLoc.X = X_MAX;
    dlArgs.StartLoc.Y = Y_START;
    dlArgs.EndLoc.X = X_MAX;
    dlArgs.EndLoc.Y = Y_START + DY_SCORE_METER;
    dlArgs.Options = 0;
    SysDrawLine(dlArgs);
    
    dlArgs.StartLoc.X = X_MAX - 3;
    dlArgs.EndLoc.X = dlArgs.StartLoc.X;
    SysDrawLine(dlArgs);

    dlArgs.StartLoc.X = X_MAX;
    dlArgs.StartLoc.Y = Y_START + DY_SCORE_METER;
    SysDrawLine(dlArgs);

    dlArgs.StartLoc.Y = Y_START;
    dlArgs.EndLoc.Y = Y_START;
    SysDrawLine(dlArgs);

    // Draw two lines of score/2 height to fill the meter (100% in 50 pixels)
    dlArgs.StartLoc.X = X_MAX - 2;
    dlArgs.EndLoc.X = dlArgs.StartLoc.X;
    dlArgs.EndLoc.Y = Y_START + percentMeter / 2;
    SysDrawLine(dlArgs);

    dlArgs.StartLoc.X = X_MAX - 1;
    dlArgs.EndLoc.X = dlArgs.StartLoc.X;
    SysDrawLine(dlArgs);
}

// This function is called when the song is expecting silence.
// If an extra note is being played then count the error.
inline void CheckForExtraNote()
{
    // Is a note being played?
    if (fPressed)
    {
       // Is this is a new note press, or if we have not yet counted an
       // extra note during this silence interval (late release),
       // then count an extra note error.
       if (!fNoteHeld | (iNoteFirst > iNoteExtraLast))  // || operator has a bug
       {
          ExtraNoteBeep();
          cNotesMissed++;
          cNotesScore++;
          iNoteExtraLast = iNoteFirst;
       }
    }
}

// Calculate percentHit and percentMeter
inline void CalculateScore()
{
    // Calculate score percent and score meter value
    if (cNotesScore == 0)
    {
       percentHit = 0;
       percentMeter = 50;  // meter starts out at 50%
    }
    else
    {
       // Calculate the actual percentHit
       long hit100 = (cNotesScore - cNotesMissed) * 100;
       percentHit = hit100 / cNotesScore;
       
       // Calculate the percentMeter, which moves slowly from 50%
       // for the first 10 notes.
       if (cNotesScore > 10)
          percentMeter = percentHit;
       else
       {
          // Use weighted average from starting position of 50%
          percentMeter = (cNotesScore * percentHit
                          + (10 - cNotesScore) * 50) / 10;
       }
    }
}

// Redraw the entire screen display
inline void RedrawAll()
{
    // Wait for a good time to draw, then draw the background items
    WaitForDisplayRefresh();
    ClearScreen();
    DrawFretSel();
    DrawStrings();

    // Draw the notes that appear on screen
    int iNote;
    for (iNote = iNoteFirst; iNote <= iNoteLast; iNote++)
    {
       int ticksAway = rgNote[iNote].tickStart - tickCur;
       if (ticksAway > TICKS_SCREEN_MAX)
          break;     // notes from here on are not on screen yet
       DrawNote(rgNote[iNote].fret, ticksAway, rgNote[iNote].ticksLength);
    }
    
    // Draw the score meter
    DrawScoreMeter();
    
    // For debugging, display the number of notes on screen
    // NumOut(0, 0, iNote - iNoteFirst);
}

// Let the user play the loaded song, and return true if they finish it.
bool FPlaySong()
{
    int tickStart, tickEnd, ticksLength, fret;

    // Init the song playing state
    for (fret = 0; fret < 5; fret++)
        rgTickFret[fret] = -TICK_MAX;   // no frets played yet
    iNoteExtraLast = 0;
    cNotesSongScored = 0;
    cNotesScore = 0;
    cNotesMissed = 0;
    fNoteHeld = FALSE;

    // Prepare the sensors and timer
    SetSensorTouch(S1);
    SetSensorTouch(S2);
    SetSensorLowspeed(S4);
    SetButtonPressCount(BTNCENTER, 0);
    InitFretReadings();
    tickSysStart = 0;

    // Main loop repeats until song finishes or user cancels
    fPressed = FALSE;
    while (iNoteFirst < cNotesSong)
    {
       if (ButtonPressCount(BTNCENTER))
          return FALSE;   // user cancelled the song
          
       // Get the current fret and pressed state from the sensors
       fretCur = FretReading();
       fNoteHeld = fPressed;
       fPressed = Sensor(S1) | Sensor(S2);  // || operator has a bug
       if (!fPressed)
          fNoteHeld = FALSE;
       
       // Get current timing tick and check for song time limit
       tickCur = TickCurrent(fPressed);
       if (tickCur > TICK_MAX)
          break;   // end the main loop

       // Keep track of the time each fret was last played
       if (fPressed)
          rgTickFret[fretCur] = tickCur;

       // Score any notes that reach the end of the scoring window,
       // and remove notes that have scrolled past the window.
       while (iNoteFirst < cNotesSong)
       {
          // Is the start of the note after the end of the scoring window?
          tickStart = rgNote[iNoteFirst].tickStart;
          if (tickStart > tickCur - TICKS_LATE_SLOP)
          {
             // Is the start of this note after the start of the window?
             if (tickStart > tickCur + TICKS_EARLY_SLOP)
                CheckForExtraNote();        // should be silence now
             break;   // done scanning for expired notes
          }

          // This start of this note has recently passed the end of the
          // scoring window, so score it if we haven't scored it yet.
          if (cNotesSongScored <= iNoteFirst)
          {
             // Compare note start time to last time that fret was played
             fret = rgNote[iNoteFirst].fret;
             if (rgTickFret[fret] + TICKS_LATE_SLOP < tickStart)
             {
                // The last time this note was played was too long ago
                MissedNoteBeep();
                cNotesMissed++;
             }
             cNotesSongScored++;
             cNotesScore++;
          }

          // Is the end of this note beyond the required release time?
          ticksLength = rgNote[iNoteFirst].ticksLength;
          tickEnd = tickStart + ticksLength;
          if (tickEnd >= tickCur - TICKS_RELEASE_SLOP)
             break;      // not past required release yet

          // Remove expired note and look at next one
          iNoteFirst++;
       }

       // Calculate the current score and redraw the display
       CalculateScore();
       RedrawAll();
       
	} // end of main loop

    // Allow time to hear any final tones after the song ends
    Wait(250);

    // Set final displayed score to the actual hit percentage
    percentMeter = percentHit;
    return TRUE;   // song finished
}

// Main program
task main()
{
    // Start looking for songs at file index 1 ("Song 1")
    int indexSong = 1;
    
    // Let the user choose and play songs until they abort
    for (;;)
    {
        // Choose a song, starting at the same song as the last try
        indexSong = IndexChooseAndReadSongFile(indexSong);
        
        // Show details for the song and allow the user to delete it
        // or continue on to play it.
        if (!FPlayShowSongDetails(indexSong))
           continue;   // user doesn't want to play it, find another
        
        // Let the user play the song and see if they finish or cancel
        bool fFinished = FPlaySong();
        ClearScreen();
        if (!fFinished)
           CenterTextOut(LCD_LINE4, "Song Cancelled");
        else
        {
           // Display score results
           DrawScoreMeter();
           CenterNumLine(LCD_LINE1, STR_EMPTY, cNotesScore, " Notes");
           CenterNumLine(LCD_LINE2, STR_EMPTY, cNotesMissed, " Missed");
           CenterNumLine(LCD_LINE4, "Score = ", percentHit, "%");
           
           // If the song's high score was beat, re-save the file to
           // record the new high score and display congratulations.
           if (percentHit > bSongHighScore)
           {
              bSongHighScore = percentHit;
              WriteSongFile(strFileNameSong);

              CenterTextOut(LCD_LINE6, "HIGH SCORE!");
              
              // Victory sound
              PlayTone(TONE_C5, 100);  Wait(100);
              PlayTone(TONE_E5, 100);  Wait(100);
              PlayTone(TONE_G5, 100);  Wait(100);
              PlayTone(TONE_C6, 100);  Wait(1000);
           }
       }
       EnterAlert();   // User presses Enter to try again or another song
    }
}

